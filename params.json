{"name":"META II","tagline":"Experiments with META II","body":"# META II\r\n\r\n> \"Get used to a way of thinking in which the hardware of the realization of an idea is much less important than the idea itself.\"\r\n>\r\n> **Valentino Braitenberg**, *Vehicles*, p. 2\r\n\r\n## Overview\r\n\r\nThis is a JavaScript implementation of the META II [metacompiler](http://en.wikipedia.org/wiki/Metacompiler) as described by Val Shorre in [the original paper from 1964](http://dl.acm.org/citation.cfm?doid=800257.808896).\r\n\r\nI used the same byte-code interpreter. So I was able to bootstrap the system using [James Neighbors' compiled version of META II](http://www.bayfronttechnologies.com/mc_tutorial.html).\r\n\r\nMETA II contains three important ideas in computing:\r\n\r\n1. the creation of domain-specific languages,\r\n2. the use of a virtual machine,\r\n3. and the ability for a system to host its own evolution.\r\n\r\n## Metalinguistic Abstraction\r\n\r\nWhen developing software systems, [creating new languages](http://en.wikipedia.org/wiki/Metalinguistic_abstraction) is sometimes the best approach for dealing with complexity. It allows the programmer to focus on the problem instead of being distracted by implementation details.\r\n\r\nMETA II is itself a language specific to the domain of compiler writing.\r\n\r\n> \"META II is a compiler writing language which consists of syntax equations resembling Backus normal form and into which instructions to output assembly language commands are inserted.\"\r\n>\r\n> **D. V. Shorre**, [*META II A Syntax-Oriented Compiler Writing Language*](http://dl.acm.org/citation.cfm?doid=800257.808896)\r\n\r\nTo create a new domain-specific language with META II, the programmer has to:\r\n\r\n1. implement the basic objects and operations of the domain in a byte-code interpreter,\r\n2. and specify the syntax and semantics of the language by writing a grammar in the META II language.\r\n\r\nPlease note that the byte-code interpreter is just one implementation of the idea that made sense in 1964. Today, we would probably implement the compiler with [threaded code](http://en.wikipedia.org/wiki/Threaded_code) or directly compile the grammar into executable code in a high-level language.\r\n\r\nThis approach has several advantages:\r\n\r\n1. The syntax and semantics of the language can be designed iteratively in a high-level domain-specific language.\r\n\r\n2. Porting the language to a new system only requires the implementation of the primitives objects and operations of the domain\r\n\r\n3. Other languages can take advantage of the primitives to implement languages with very different syntax and semantics.\r\n\r\n## Metacompiler\r\n\r\nThe main difference between META II and other [compiler writing tools](http://en.wikipedia.org/wiki/Compiler-compiler) is that META II can compile itself. In other words, META II is described using the language it implements. That is why it is called a [metacompiler](http://en.wikipedia.org/wiki/Metacompiler).\r\n\r\nBelow is the description of META II in META II from the [original paper](http://dl.acm.org/citation.cfm?doid=800257.808896).\r\n\r\n    .SYNTAX PROGRAM\r\n\r\n    OUT1 = '*1'     .OUT('GN1')\r\n         / '*2'     .OUT('GN2')\r\n         / '*'      .OUT('CI')\r\n         / .STRING  .OUT('CL ' *).,\r\n\r\n    OUTPUT = ('.OUT' '(' $ OUT1 ')' / '.LABEL' .OUT('LB') OUT1)\r\n             .OUT('OUT') .,\r\n\r\n    EX3 = .ID               .OUT('CLL ' *)\r\n        / .STRING           .OUT('TST ' *)\r\n        / '.ID'             .OUT('ID')\r\n        / '.NUMBER'         .OUT('NUM')\r\n        / '.STRING'         .OUT('SR')\r\n        / '(' EX1 ')' \r\n        / '.EMPTY'          .OUT('SET')\r\n        / '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET').,\r\n\r\n    EX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\r\n          $ (EX3 .OUT('BE') / OUTPUT)\r\n          .LABEL *1 .,\r\n\r\n    EX1 = EX2\r\n          $ ('/' .OUT('BT ' *1) EX2)\r\n          .LABEL *1 .,\r\n\r\n    ST = .ID .LABEL * '=' EX1 '.,' .OUT('R').,\r\n\r\n    PROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\r\n              $ ST\r\n              '.END'        .OUT('END').,\r\n\r\n    .END\r\n\r\nA detailed explanation of the syntax and semantics of META II is given in [METAII.md](METAII.md).\r\n\r\nBecause the META II language is described in itself, we can change its syntax by simply modifying the grammar and recompiling it. This operation generally requires two steps:\r\n\r\n1. Modify the grammar to recognize the new language\r\n2. Re-write the grammar in the new META language\r\n\r\nPlease note that the language we obtained after the first step is not a META language since it cannot compile itself.\r\n\r\n## Usage\r\n\r\n### To Create a Language\r\n\r\nCreate the compiler for your new language with:\r\n\r\n    node compile.js bootstrap/meta2.o <grammar file>\r\n\r\nThis should write the assembly code for the new compiler on stdout.\r\n\r\nTo use the new compiler on a program:\r\n\r\n    node compile.js <compiled grammar> <your program>\r\n\r\nThis should write the assembly code for your own byte-code interpreter on stdout.\r\n\r\n### To Create a META language\r\n\r\nFirst, you can make sure our META II language compile itself with:\r\n\r\n    node compile.js bootstrap/meta2.o lib/meta2 | diff bootstrap/meta2.o -\r\n\r\nYou can modify the grammar to recognize a new META language and compile it with:\r\n\r\n    node compile.js bootstrap/meta2.o <new grammar>\r\n\r\nThen you can use your new META language to describe itself and compile it with:\r\n\r\n    node compile.js <compiled grammar> <new META grammar>\r\n\r\nYou should get back the compiled version of the new META grammar.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}